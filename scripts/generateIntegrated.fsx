// dotnet fsi .\scripts\generateIntegrated.fsx > .\SIMDIntCompression\SimdBitPacking32D4.Simd.cs

let length = 32
let vectorSize = 128
let vt = $"V{vectorSize}i" // abbreviation for Vector128<uint>
let load = $"Vector{vectorSize}.Load"
let store = $"Vector{vectorSize}.Store"
let create = $"Vector{vectorSize}.Create"

// a, b are V128i
let mkDelta (curr: string) (prev: string) =
    $"{curr} - {prev}"

let mkPrefixSum (curr: string) (prev: string) =
    $"{curr} + {prev}"

let delta = mkDelta "currIn" "initOffset"

let packBitInternal bit =
    let mutable inWordPointer = 0
    let mutable valueCounter = 0

    let mutable k = 0
    let m = ceil (float length * float bit) / float length |> int

    seq {
        while k < m do
            if valueCounter = length then
                k <- bit // "break"

            for x in inWordPointer .. bit .. 31 do
                if x <> 0 then $"        outReg |= inReg << {x};"
                else "        outReg = inReg;"

                if x + bit >= 32 then
                    while inWordPointer < length do
                        inWordPointer <- inWordPointer + bit
                    $"        {store}(outReg, (uint*)output);" 

                    if valueCounter + 1 < length then
                        "        ++output;"

                    inWordPointer <- inWordPointer - 32

                    if inWordPointer > 0 then
                        $"        outReg = inReg >> {bit - inWordPointer}; "

                if valueCounter + 1 < 32 then
                    $"        currIn = {load}((uint*)++inVec);"
                    $"        inReg = {delta};"
                    $"        initOffset = currIn;\n"
                valueCounter <- valueCounter + 1

                if valueCounter = 32 then
                    k <- bit // "break"
            
            k <- k + 1
    } 
    |> String.concat "\n"

let packBit bit = $$"""
    private static void Pack{{bit}}({{vt}} initOffset, uint* input, {{vt}}* output)
    {
        {{vt}}* inVec = ({{vt}}*)input;
        {{vt}} outReg;

        {{vt}} currIn = {{load}}((uint*)inVec);
        {{vt}} inReg = {{mkDelta "currIn" "initOffset"}};
        initOffset = currIn;

{{packBitInternal bit}}
    }
"""

let unpackBitInternal bit =
    let mutable inWordPointer = 0
    let mutable valueCounter = 0

    let mutable k = 0
    let m = ceil (float length * float bit) / 32.0 |> int

    [
        while k < m do
            for x in inWordPointer .. bit .. 31 do
                if valueCounter = length then
                    k <- m // "break"

                if x > 0 then
                    $"tmp = inReg >> {x};"
                else
                    $"tmp=inReg;"

                if x + bit < 32 then
                    $"outReg = tmp & mask;"
                else
                    $"outReg = tmp;"
                    if k <> m - 1 then
                        $"inReg = {load}((uint*)++input);"

                if x + bit >= 32 then
                    while inWordPointer < 32 do
                        inWordPointer <- inWordPointer + bit

                    inWordPointer <- inWordPointer - 32

                    if inWordPointer > 0 then
                        $"outReg |= (inReg << {bit} - {inWordPointer}) & mask;"

                $"""outReg = {mkPrefixSum "outReg" "initOffset"};"""
                "initOffset = outReg;"

                $"{store}(outReg, (uint*)outVec++);\n"

                valueCounter <- valueCounter + 1

                if valueCounter = length then
                    k <- m // "break"

            k <- k + 1
    ]
    |> List.map (sprintf "        %s")
    |> String.concat "\n"

let unpackBit bit = $$"""
    private static {{vt}} Unpack{{bit}}({{vt}} initOffset, {{vt}}* input, uint* output)
    {
        {{vt}}* outVec = ({{vt}}*)output;
        {{vt}} inReg = {{load}}((uint*)input);
        {{vt}} outReg;
        {{vt}} tmp;
        {{vt}} mask = {{create}}((1u << {{bit}}) - 1);

{{unpackBitInternal bit}}
        return initOffset;
    }
"""


$$"""// This file was automatically generated by generate.fsx. Do not modify directly.
// 
// To regenerate this file, run the following command:
// dotnet fsi .\scripts\generateIntegrated.fsx > .\SIMDIntCompression\SimdBitPacking32D4.Simd.cs
//
// References:
// https://github.com/fast-pack/SIMDCompressionAndIntersection

namespace SIMDIntCompression;

using System.Runtime.Intrinsics;

using {{vt}} = System.Runtime.Intrinsics.Vector128<uint>;

/// <summary>
/// SIMD bit packing/unpacking for 32-bit (unsigned) integers.
/// </summary>
public static unsafe partial class SimdBitPacking32D4
{
    private const int VectorSize = {{vectorSize}};

    private static void Pack0({{vt}} initOffset, uint* input, {{vt}}* output) { }

{{String.concat "\n" [for bit in 1..32 do packBit bit]}}

    private static {{vt}} Unpack0({{vt}} initOffset, {{vt}}* input, uint* output)
    {
        {{vt}}* outVec = ({{vt}}*)output;
        {{vt}} zero = {{vt}}.Zero;

        for (int i = 0; i < 8; i++)
        {
            initOffset = {{mkPrefixSum "zero" "initOffset"}};
            {{store}}(initOffset, (uint*)outVec++);
            initOffset = {{mkPrefixSum "zero" "initOffset"}};
            {{store}}(initOffset, (uint*)outVec++);
            initOffset = {{mkPrefixSum "zero" "initOffset"}};
            {{store}}(initOffset, (uint*)outVec++);
            initOffset = {{mkPrefixSum "zero" "initOffset"}};
            {{store}}(initOffset, (uint*)outVec++);
        }
        return initOffset;
    }

{{String.concat "\n" [for bit in 1..31 do unpackBit bit]}}

    private static {{vt}} Unpack32({{vt}} initOffset, {{vt}}* input, uint* output)
    {
        {{vt}}* outVec = ({{vt}}*)output;
        {{vt}} inVec = default;
        for (int outer = 0; outer < {{vectorSize / sizeof<uint>}}; outer++)
        {
            inVec = {{load}}((uint*)input++);
            {{store}}(inVec, (uint*)outVec++);
        }
        return inVec;
    }

    public static void Pack({{vt}} initOffset, uint* input, {{vt}}* output, int bit)
    {
        switch (bit)
        {{{String.concat "" [for bit in 0..32 do $"
            case {bit}: Pack{bit}(initOffset, input, output); break; "]}}
            // NOTE: Pack32 could be further optimized since it's an extreme edge case
            default: throw new ArgumentException("Unsupported bit width.");
        }
    }

    public static {{vt}} Unpack({{vt}} initOffset, {{vt}}* input, uint* output, int bit) => bit switch
    {{{String.concat "" [for bit in 0..32 do $"
        {bit} => Unpack{bit}(initOffset, input, output),"]}}
        _ => throw new ArgumentException("Unsupported bit width.")
    };
}
"""
|> _.Replace("outReg = outReg +","outReg +=")
    .Split('\n') 
|> Seq.filter (_.Trim() >> (<>) "initOffset = zero + initOffset;") 
|> String.concat "\n"
|> printfn "%s"